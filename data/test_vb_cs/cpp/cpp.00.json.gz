{"repo_name":"yaqiyang/autorest","ref":"refs/heads/master","path":"src/generator/AutoRest.CSharp.Tests/Expected/AcceptanceTests/Http/Models/C.cs","copies":"6","content":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for\n// license information.\n// \n// Code generated by Microsoft (R) AutoRest Code Generator.\n// Changes may cause incorrect behavior and will be lost if the code is\n// regenerated.\n\nnamespace Fixtures.AcceptanceTestsHttp.Models\n{\n    using System.Linq;\n\n    public partial class C\n    {\n        /// \u003csummary\u003e\n        /// Initializes a new instance of the C class.\n        /// \u003c/summary\u003e\n        public C() { }\n\n        /// \u003csummary\u003e\n        /// Initializes a new instance of the C class.\n        /// \u003c/summary\u003e\n        public C(string httpCode = default(string))\n        {\n            HttpCode = httpCode;\n        }\n\n        /// \u003csummary\u003e\n        /// \u003c/summary\u003e\n        [Newtonsoft.Json.JsonProperty(PropertyName = \"httpCode\")]\n        public string HttpCode { get; set; }\n\n    }\n}\n"}
{"repo_name":"ramarag/coreclr","ref":"refs/heads/master","path":"tests/src/CoreMangLib/cti/system/collections/generic/equalitycomparer/equlitycomparerdefault.cs","copies":"79","content":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\nusing System;\nusing System.Collections.Generic;\n\n\n/// \u003csummary\u003e\n/// System.Collections.Generic.EqualityComparer.Default\n/// \u003c/summary\u003e\npublic class GenericEqualityComparerDefault\n{\n    \n    public static int Main(string[] args)\n    {\n        GenericEqualityComparerDefault testObj = new GenericEqualityComparerDefault();\n        TestLibrary.TestFramework.BeginTestCase(\"Testing for Property: System.Collections.Generic.EqualityComparer.Default)\");\n\n        if (testObj.RunTests())\n        {\n            TestLibrary.TestFramework.EndTestCase();\n            TestLibrary.TestFramework.LogInformation(\"PASS\");\n            return 100;\n        }\n        else\n        {\n            TestLibrary.TestFramework.EndTestCase();\n            TestLibrary.TestFramework.LogInformation(\"FAIL\");\n            return 0;\n        }\n    }\n\n    public bool RunTests()\n    {\n        bool retVal = true;\n\n        TestLibrary.TestFramework.LogInformation(\"[Positive]\");\n        retVal = PosTest1() \u0026\u0026 retVal;\n        retVal = PosTest2() \u0026\u0026 retVal;\n        retVal = PosTest3() \u0026\u0026 retVal;\n        retVal = PosTest4() \u0026\u0026 retVal;\n\n        return retVal;\n    }\n    #region Positive tests\n    public bool PosTest1()\n    {\n        bool retVal = true;\n        const string c_TEST_DESC = \"PosTest1: Verify EqualityComparer.Defalut when Type is int ...\";\n        const string c_TEST_ID = \"P001\";\n\n       \n        \n        TestLibrary.TestFramework.BeginScenario(c_TEST_DESC);\n\n        try\n        {\n            EqualityComparer\u003cint\u003e defaultEC = EqualityComparer\u003cint\u003e.Default;\n      \n            if (defaultEC == null)\n            {\n                string errorDesc = \"Value should be not null\";\n                TestLibrary.TestFramework.LogError(\"001\" + \" TestId-\" + c_TEST_ID, errorDesc);\n                retVal = false;\n            }\n\n        }\n        catch (Exception e)\n        {\n            TestLibrary.TestFramework.LogError(\"002\", \"Unecpected exception occurs :\" + e);\n            retVal = false;\n        }\n\n        return retVal;\n    }\n\n    public bool PosTest2()\n    {\n        bool retVal = true;\n        const string c_TEST_DESC = \"PosTest2: Verify EqualityComparer.Defalut when Type is byte ...\";\n        const string c_TEST_ID = \"P002\";\n\n\n\n        TestLibrary.TestFramework.BeginScenario(c_TEST_DESC);\n\n        try\n        {\n            EqualityComparer\u003cbyte\u003e defaultEC = EqualityComparer\u003cbyte\u003e.Default;\n            if (defaultEC == null)\n            {\n                string errorDesc = \"Value is not EqualityComparer\u003cbyte\u003e\";\n                TestLibrary.TestFramework.LogError(\"003\" + \" TestId-\" + c_TEST_ID, errorDesc);\n                retVal = false;\n            }\n\n        }\n        catch (Exception e)\n        {\n            TestLibrary.TestFramework.LogError(\"004\", \"Unecpected exception occurs :\" + e);\n            retVal = false;\n        }\n\n        return retVal;\n    }\n\n    public bool PosTest3()\n    {\n        bool retVal = true;\n        const string c_TEST_DESC = \"PosTest3: Verify EqualityComparer.Defalut when Type is reference type ...\";\n        const string c_TEST_ID = \"P003\";\n\n        TestLibrary.TestFramework.BeginScenario(c_TEST_DESC);\n\n        try\n        {\n            EqualityComparer\u003cRandom\u003e defaultEC = EqualityComparer\u003cRandom\u003e.Default;\n            if (defaultEC == null)\n            {\n                string errorDesc = \"Value should be not null\";\n                TestLibrary.TestFramework.LogError(\"005\" + \" TestId-\" + c_TEST_ID, errorDesc);\n                retVal = false;\n            }\n\n        }\n        catch (Exception e)\n        {\n            TestLibrary.TestFramework.LogError(\"006\", \"Unecpected exception occurs :\" + e);\n            retVal = false;\n        }\n\n        return retVal;\n    }\n\n    public bool PosTest4()\n    {\n        bool retVal = true;\n        const string c_TEST_DESC = \"PosTest4: Verify EqualityComparer.Defalut when Type is a user-defined type ...\";\n        const string c_TEST_ID = \"P004\";\n\n        TestLibrary.TestFramework.BeginScenario(c_TEST_DESC);\n\n        try\n        {\n            EqualityComparer\u003cMyClass\u003e defaultEC = EqualityComparer\u003cMyClass\u003e.Default;\n            if (defaultEC == null)\n            {\n                string errorDesc = \"Value should be not null\";\n                TestLibrary.TestFramework.LogError(\"007\" + \" TestId-\" + c_TEST_ID, errorDesc);\n                retVal = false;\n            }\n\n        }\n        catch (Exception e)\n        {\n            TestLibrary.TestFramework.LogError(\"008\", \"Unecpected exception occurs :\" + e);\n            retVal = false;\n        }\n\n        return retVal;\n    }\n\n    #endregion\n\n    #region Help Class\n    public class MyEqualityComparer\u003cT\u003e : EqualityComparer\u003cT\u003e\n    {\n\n        public override bool Equals(T x, T y)\n        {\n            throw new Exception(\"The method or operation is not implemented.\");\n        }\n\n        public override int GetHashCode(T obj)\n        {\n            if (obj == null)\n                throw new ArgumentNullException();\n            return obj.GetHashCode();\n        }\n       \n    }\n    public class MyClass\n    {\n    }\n    #endregion\n}\n"}
{"repo_name":"hwthomas/xwt","ref":"refs/heads/master","path":"Testing/Tests/DatePickerTests.cs","copies":"16","content":"//\n// DatePickerTests.cs\n//\n// Author:\n//       Lluis Sanchez \u003clluis@xamarin.com\u003e\n//\n// Copyright (c) 2013 Xamarin Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nusing System;\n\nnamespace Xwt\n{\n\tpublic class DatePickerTests: WidgetTests\n\t{\n\t\tpublic override Widget CreateWidget ()\n\t\t{\n\t\t\treturn new DatePicker ();\n\t\t}\n\t}\n}\n\n"}
{"repo_name":"stumoodie/PathwayEditor","ref":"refs/heads/master","path":"libs/antlr-3.4/runtime/CSharp2/Sources/Antlr3.Runtime/Antlr.Runtime/MismatchedTreeNodeException.cs","copies":"14","content":"/*\n * [The \"BSD licence\"]\n * Copyright (c) 2005-2008 Terence Parr\n * All rights reserved.\n *\n * Conversion to C#:\n * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nnamespace Antlr.Runtime {\n    using ArgumentNullException = System.ArgumentNullException;\n    using Exception = System.Exception;\n    using ITreeNodeStream = Antlr.Runtime.Tree.ITreeNodeStream;\n    using SerializationInfo = System.Runtime.Serialization.SerializationInfo;\n    using StreamingContext = System.Runtime.Serialization.StreamingContext;\n\n    [System.Serializable]\n    public class MismatchedTreeNodeException : RecognitionException {\n        private readonly int _expecting;\n\n        public MismatchedTreeNodeException() {\n        }\n\n        public MismatchedTreeNodeException(string message)\n            : base(message) {\n        }\n\n        public MismatchedTreeNodeException(string message, Exception innerException)\n            : base(message, innerException) {\n        }\n\n        public MismatchedTreeNodeException(int expecting, ITreeNodeStream input)\n            : base(input) {\n            this._expecting = expecting;\n        }\n\n        public MismatchedTreeNodeException(string message, int expecting, ITreeNodeStream input)\n            : base(message, input) {\n            this._expecting = expecting;\n        }\n\n        public MismatchedTreeNodeException(string message, int expecting, ITreeNodeStream input, Exception innerException)\n            : base(message, input, innerException) {\n            this._expecting = expecting;\n        }\n\n        protected MismatchedTreeNodeException(SerializationInfo info, StreamingContext context)\n            : base(info, context) {\n            if (info == null)\n                throw new ArgumentNullException(\"info\");\n\n            this._expecting = info.GetInt32(\"Expecting\");\n        }\n\n        public int Expecting {\n            get {\n                return _expecting;\n            }\n        }\n\n        public override void GetObjectData(SerializationInfo info, StreamingContext context) {\n            if (info == null)\n                throw new ArgumentNullException(\"info\");\n\n            base.GetObjectData(info, context);\n            info.AddValue(\"Expecting\", _expecting);\n        }\n\n        public override string ToString() {\n            return \"MismatchedTreeNodeException(\" + UnexpectedType + \"!=\" + Expecting + \")\";\n        }\n    }\n}\n"}
{"repo_name":"chinnurtb/OpenAdStack","ref":"refs/heads/master","path":"External/Json45r7/Source/Src/Newtonsoft.Json/Utilities/MethodCall.cs","copies":"44","content":"#region License\n// Copyright (c) 2007 James Newton-King\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation\n// files (the \"Software\"), to deal in the Software without\n// restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following\n// conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n// OTHER DEALINGS IN THE SOFTWARE.\n#endregion\n\nnamespace Newtonsoft.Json.Utilities\n{\n  internal delegate TResult MethodCall\u003cT, TResult\u003e(T target, params object[] args);\n}"}
{"repo_name":"MicrosoftLearning/20486-DevelopingASPNETMVCWebApplications","ref":"refs/heads/master","path":"Allfiles/20486C/Mod11/LabFiles/PhotoSharingApplication_11_end/PhotoSharingApplication/Properties/AssemblyInfo.cs","copies":"24","content":"﻿using System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\n// General Information about an assembly is controlled through the following\n// set of attributes. Change these attribute values to modify the information\n// associated with an assembly.\n[assembly: AssemblyTitle(\"PhotoSharingApplication\")]\n[assembly: AssemblyDescription(\"\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]\n[assembly: AssemblyProduct(\"PhotoSharingApplication\")]\n[assembly: AssemblyCopyright(\"Copyright ©  2017\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n// Setting ComVisible to false makes the types in this assembly not visible\n// to COM components.  If you need to access a type in this assembly from\n// COM, set the ComVisible attribute to true on that type.\n[assembly: ComVisible(false)]\n\n// The following GUID is for the ID of the typelib if this project is exposed to COM\n[assembly: Guid(\"76eafe29-b1f0-4206-8423-957a621e0c62\")]\n\n// Version information for an assembly consists of the following four values:\n//\n//      Major Version\n//      Minor Version\n//      Build Number\n//      Revision\n//\n// You can specify all the values or you can default the Revision and Build Numbers\n// by using the '*' as shown below:\n[assembly: AssemblyVersion(\"1.0.0.0\")]\n[assembly: AssemblyFileVersion(\"1.0.0.0\")]\n"}
{"repo_name":"alobakov/nhibernate-core","ref":"refs/heads/master","path":"src/NHibernate.Test/Linq/LoggingTests.cs","copies":"6","content":"using System.Linq;\nusing NHibernate.Cfg;\nusing NHibernate.DomainModel.Northwind.Entities;\nusing NUnit.Framework;\n\nnamespace NHibernate.Test.Linq\n{\n\t[TestFixture]\n\tpublic class LoggingTests : LinqTestCase\n\t{\n\t\t[Test]\n\t\tpublic void PageBetweenProjections()\n\t\t{\n\t\t\tusing (var spy = new LogSpy(\"NHibernate.Linq\"))\n\t\t\t{\n\t\t\t\tvar subquery = db.Products.Where(p =\u003e p.ProductId \u003e 5);\n\n\t\t\t\tvar list = db.Products.Where(p =\u003e subquery.Contains(p))\n\t\t\t\t             .Skip(5).Take(10)\n\t\t\t\t             .ToList();\n\n\t\t\t\tvar logtext = spy.GetWholeLog();\n\n\t\t\t\tconst string expected =\n\t\t\t\t\t\"Expression (partially evaluated): value(NHibernate.Linq.NhQueryable`1[NHibernate.DomainModel.Northwind.Entities.Product]).Where(p =\u003e value(NHibernate.Linq.NhQueryable`1[NHibernate.DomainModel.Northwind.Entities.Product]).Where(p =\u003e (p.ProductId \u003e 5)).Contains(p)).Skip(5).Take(10)\";\n\t\t\t\tAssert.That(logtext, Does.Contain(expected));\n\t\t\t}\n\t\t}\n\n\n\t\t[Test]\n\t\tpublic void CanLogLinqExpressionWithoutInitializingContainedProxy()\n\t\t{\n\t\t\tvar productId = db.Products.Select(p =\u003e p.ProductId).First();\n\n\t\t\tusing (var logspy = new LogSpy(\"NHibernate.Linq\"))\n\t\t\t{\n\t\t\t\tvar productProxy = session.Load\u003cProduct\u003e(productId);\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(productProxy), Is.False);\n\n\t\t\t\tvar result = from product in db.Products\n\t\t\t\t             where product == productProxy\n\t\t\t\t             select product;\n\n\t\t\t\tAssert.That(result.Count(), Is.EqualTo(1));\n\n\t\t\t\t// Verify that the expected logging did happen.\n\t\t\t\tvar actualLog = logspy.GetWholeLog();\n\n\t\t\t\tstring expectedLog =\n\t\t\t\t\t\"Expression (partially evaluated): value(NHibernate.Linq.NhQueryable`1[NHibernate.DomainModel.Northwind.Entities.Product])\" +\n\t\t\t\t\t\".Where(product =\u003e (product == Product#\" + productId + \")).Count()\";\n\t\t\t\tAssert.That(actualLog, Does.Contain(expectedLog));\n\n\t\t\t\t// And verify that the proxy in the expression wasn't initialized.\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(productProxy), Is.False,\n\t\t\t\t            \"ERROR: We expected the proxy to NOT be initialized.\");\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"repo_name":"chenxizhang/roslyn","ref":"refs/heads/master","path":"src/Compilers/CSharp/Portable/Syntax/ParameterSyntax.cs","copies":"170","content":"﻿// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing Microsoft.CodeAnalysis.CSharp.Symbols;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Text;\n\nnamespace Microsoft.CodeAnalysis.CSharp.Syntax\n{\n    public partial class ParameterSyntax\n    {\n        internal bool IsArgList\n        {\n            get\n            {\n                return this.Type == null \u0026\u0026 this.Identifier.ContextualKind() == SyntaxKind.ArgListKeyword;\n            }\n        }\n    }\n}\n"}
{"repo_name":"hanjia2014/EnlightmentSwords","ref":"refs/heads/master","path":"src/Orchard.Web/Modules/Orchard.Fields/Settings/EnumerationFieldEditorEvents.cs","copies":"88","content":"﻿using System.Collections.Generic;\r\nusing System.Globalization;\r\nusing Orchard.ContentManagement;\r\nusing Orchard.ContentManagement.MetaData;\r\nusing Orchard.ContentManagement.MetaData.Builders;\r\nusing Orchard.ContentManagement.MetaData.Models;\r\nusing Orchard.ContentManagement.ViewModels;\r\n\r\nnamespace Orchard.Fields.Settings {\r\n    public class EnumerationFieldListModeEvents : ContentDefinitionEditorEventsBase {\r\n\r\n        public override IEnumerable\u003cTemplateViewModel\u003e PartFieldEditor(ContentPartFieldDefinition definition) {\r\n            if (definition.FieldDefinition.Name == \"EnumerationField\") {\r\n                var model = definition.Settings.GetModel\u003cEnumerationFieldSettings\u003e();\r\n                yield return DefinitionTemplate(model);\r\n            }\r\n        }\r\n\r\n        public override IEnumerable\u003cTemplateViewModel\u003e PartFieldEditorUpdate(ContentPartFieldDefinitionBuilder builder, IUpdateModel updateModel) {\r\n            if (builder.FieldType != \"EnumerationField\") {\r\n                yield break;\r\n            }\r\n\r\n            var model = new EnumerationFieldSettings();\r\n            if (updateModel.TryUpdateModel(model, \"EnumerationFieldSettings\", null, null)) {\r\n                builder.WithSetting(\"EnumerationFieldSettings.Hint\", model.Hint);\r\n                builder.WithSetting(\"EnumerationFieldSettings.Required\", model.Required.ToString(CultureInfo.InvariantCulture));\r\n                builder.WithSetting(\"EnumerationFieldSettings.Options\", model.Options);\r\n                builder.WithSetting(\"EnumerationFieldSettings.ListMode\", model.ListMode.ToString());\r\n            }\r\n\r\n            yield return DefinitionTemplate(model);\r\n        }\r\n    }\r\n}"}
{"repo_name":"jpsullivan/lucenenet","ref":"refs/heads/master","path":"src/contrib/Analyzers/Compound/Hyphenation/PatternParser.cs","copies":"5","content":"//using System;\n//using System.Collections;\n//using System.Collections.Generic;\n//using System.IO;\n//using System.Linq;\n//using System.Text;\n//using Lucene.Net.Analysis.Compound.Hyphenation;\n\n//namespace Lucene.Net.Analyzers.Compound.Hyphenation\n//{\n// /*\n// * A SAX document handler to read and parse hyphenation patterns from a XML\n// * file.\n// * \n// * This class has been taken from the Apache FOP project (http://xmlgraphics.apache.org/fop/). They have been slightly modified. \n// */\n//public class PatternParser : DefaultHandler, PatternConsumer {\n\n//  XMLReader parser;\n\n//  int currElement;\n\n//  PatternConsumer consumer;\n\n//  StringBuilder token;\n\n//  ArrayList exception;\n\n//  char hyphenChar;\n\n//  String errMsg;\n\n//  static readonly int ELEM_CLASSES = 1;\n\n//  static readonly int ELEM_EXCEPTIONS = 2;\n\n//  static readonly int ELEM_PATTERNS = 3;\n\n//  static readonly int ELEM_HYPHEN = 4;\n\n//  public PatternParser() \n//  {\n//    token = new StringBuilder();\n//    parser = CreateParser();\n//    parser.SetContentHandler(this);\n//    parser.SetErrorHandler(this);\n//    parser.SetEntityResolver(this);\n//    hyphenChar = '-'; // default\n\n//  }\n\n//  public PatternParser(PatternConsumer consumer)\n//      : this()\n//  {\n//    this.consumer = consumer;\n//  }\n\n//  public void setConsumer(PatternConsumer consumer) {\n//    this.consumer = consumer;\n//  }\n\n//  /*\n//   * Parses a hyphenation pattern file.\n//   * \n//   * @param filename the filename\n//   * @throws HyphenationException In case of an exception while parsing\n//   */\n//  public void parse(String filename) \n//  {\n//    parse(new FileInfo(filename));\n//  }\n\n//  /*\n//   * Parses a hyphenation pattern file.\n//   * \n//   * @param file the pattern file\n//   * @throws HyphenationException In case of an exception while parsing\n//   */\n//  public void parse(FileInfo file) \n//  {\n//    try {\n//      InputSource src = new InputSource(file.toURL().toExternalForm());\n//      parse(src);\n//    } catch (MalformedURLException e) {\n//      throw new HyphenationException(\"Error converting the File '\" + file\n//          + \"' to a URL: \" + e.GetMessage());\n//    }\n//  }\n\n//  /*\n//   * Parses a hyphenation pattern file.\n//   * \n//   * @param source the InputSource for the file\n//   * @throws HyphenationException In case of an exception while parsing\n//   */\n//  public void parse(InputSource source) \n//  {\n//    try {\n//      parser.parse(source);\n//    } catch (FileNotFoundException fnfe) {\n//      throw new HyphenationException(\"File not found: \" + fnfe.GetMessage());\n//    } catch (IOException ioe) {\n//      throw new HyphenationException(ioe.GetMessage());\n//    } catch (SAXException e) {\n//      throw new HyphenationException(errMsg);\n//    }\n//  }\n\n//  /*\n//   * Creates a SAX parser using JAXP\n//   * \n//   * @return the created SAX parser\n//   */\n//  static XMLReader createParser() {\n//    try {\n//      SAXParserFactory factory = SAXParserFactory.newInstance();\n//      factory.SetNamespaceAware(true);\n//      return factory.newSAXParser().GetXMLReader();\n//    } catch (Exception e) {\n//      throw new RuntimeException(\"Couldn't create XMLReader: \" + e.GetMessage());\n//    }\n//  }\n\n//  protected String readToken(StringBuffer chars) {\n//    String word;\n//    bool space = false;\n//    int i;\n//    for (i = 0; i \u003c chars.Length(); i++) {\n//      if (char.isWhitespace(chars.charAt(i))) {\n//        space = true;\n//      } else {\n//        break;\n//      }\n//    }\n//    if (space) {\n//      // chars.delete(0,i);\n//      for (int countr = i; countr \u003c chars.Length(); countr++) {\n//        chars.SetCharAt(countr - i, chars.charAt(countr));\n//      }\n//      chars.SetLength(chars.Length() - i);\n//      if (token.Length() \u003e 0) {\n//        word = token.ToString();\n//        token.SetLength(0);\n//        return word;\n//      }\n//    }\n//    space = false;\n//    for (i = 0; i \u003c chars.Length(); i++) {\n//      if (char.isWhitespace(chars.charAt(i))) {\n//        space = true;\n//        break;\n//      }\n//    }\n//    token.Append(chars.ToString().substring(0, i));\n//    // chars.delete(0,i);\n//    for (int countr = i; countr \u003c chars.Length(); countr++) {\n//      chars.SetCharAt(countr - i, chars.charAt(countr));\n//    }\n//    chars.SetLength(chars.Length() - i);\n//    if (space) {\n//      word = token.ToString();\n//      token.SetLength(0);\n//      return word;\n//    }\n//    token.Append(chars);\n//    return null;\n//  }\n\n//  protected static String getPattern(String word) {\n//    StringBuilder pat = new StringBuilder();\n//    int len = word.Length();\n//    for (int i = 0; i \u003c len; i++) {\n//      if (!char.isDigit(word.charAt(i))) {\n//        pat.Append(word.charAt(i));\n//      }\n//    }\n//    return pat.ToString();\n//  }\n\n//  protected ArrayList normalizeException(ArrayList ex) {\n//    ArrayList res = new ArrayList();\n//    for (int i = 0; i \u003c ex.size(); i++) {\n//      Object item = ex.Get(i);\n//      if (item instanceof String) {\n//        String str = (String) item;\n//        StringBuilder buf = new StringBuilder();\n//        for (int j = 0; j \u003c str.Length(); j++) {\n//          char c = str.charAt(j);\n//          if (c != hyphenChar) {\n//            buf.Append(c);\n//          } else {\n//            res.add(buf.ToString());\n//            buf.SetLength(0);\n//            char[] h = new char[1];\n//            h[0] = hyphenChar;\n//            // we use here hyphenChar which is not necessarily\n//            // the one to be printed\n//            res.add(new Hyphen(new String(h), null, null));\n//          }\n//        }\n//        if (buf.Length() \u003e 0) {\n//          res.add(buf.ToString());\n//        }\n//      } else {\n//        res.add(item);\n//      }\n//    }\n//    return res;\n//  }\n\n//  protected String getExceptionWord(ArrayList ex) {\n//    StringBuilder res = new StringBuilder();\n//    for (int i = 0; i \u003c ex.size(); i++) {\n//      Object item = ex.Get(i);\n//      if (item instanceof String) {\n//        res.Append((String) item);\n//      } else {\n//        if (((Hyphen) item).noBreak != null) {\n//          res.Append(((Hyphen) item).noBreak);\n//        }\n//      }\n//    }\n//    return res.ToString();\n//  }\n\n//  protected static String getInterletterValues(String pat) {\n//    StringBuilder il = new StringBuilder();\n//    String word = pat + \"a\"; // add dummy letter to serve as sentinel\n//    int len = word.Length();\n//    for (int i = 0; i \u003c len; i++) {\n//      char c = word.charAt(i);\n//      if (char.isDigit(c)) {\n//        il.Append(c);\n//        i++;\n//      } else {\n//        il.Append('0');\n//      }\n//    }\n//    return il.ToString();\n//  }\n\n//  //\n//  // EntityResolver methods\n//  //\n//  public override InputSource resolveEntity(String publicId, String systemId) {\n//    return HyphenationDTDGenerator.generateDTD();\n//  }\n\n//  //\n//  // ContentHandler methods\n//  //\n\n//  /*\n//   * @see org.xml.sax.ContentHandler#startElement(java.lang.String,\n//   *      java.lang.String, java.lang.String, org.xml.sax.Attributes)\n//   */\n//  public override void startElement(String uri, String local, String raw,\n//      Attributes attrs) {\n//    if (local.equals(\"hyphen-char\")) {\n//      String h = attrs.GetValue(\"value\");\n//      if (h != null \u0026\u0026 h.Length() == 1) {\n//        hyphenChar = h.charAt(0);\n//      }\n//    } else if (local.equals(\"classes\")) {\n//      currElement = ELEM_CLASSES;\n//    } else if (local.equals(\"patterns\")) {\n//      currElement = ELEM_PATTERNS;\n//    } else if (local.equals(\"exceptions\")) {\n//      currElement = ELEM_EXCEPTIONS;\n//      exception = new ArrayList();\n//    } else if (local.equals(\"hyphen\")) {\n//      if (token.Length() \u003e 0) {\n//        exception.add(token.ToString());\n//      }\n//      exception.add(new Hyphen(attrs.GetValue(\"pre\"), attrs.GetValue(\"no\"),\n//          attrs.GetValue(\"post\")));\n//      currElement = ELEM_HYPHEN;\n//    }\n//    token.SetLength(0);\n//  }\n\n//  /*\n//   * @see org.xml.sax.ContentHandler#endElement(java.lang.String,\n//   *      java.lang.String, java.lang.String)\n//   */\n//  public override void endElement(String uri, String local, String raw) {\n\n//    if (token.Length() \u003e 0) {\n//      String word = token.ToString();\n//      switch (currElement) {\n//        case ELEM_CLASSES:\n//          consumer.addClass(word);\n//          break;\n//        case ELEM_EXCEPTIONS:\n//          exception.add(word);\n//          exception = normalizeException(exception);\n//          consumer.addException(getExceptionWord(exception),\n//              (ArrayList) exception.clone());\n//          break;\n//        case ELEM_PATTERNS:\n//          consumer.addPattern(getPattern(word), getInterletterValues(word));\n//          break;\n//        case ELEM_HYPHEN:\n//          // nothing to do\n//          break;\n//      }\n//      if (currElement != ELEM_HYPHEN) {\n//        token.SetLength(0);\n//      }\n//    }\n//    if (currElement == ELEM_HYPHEN) {\n//      currElement = ELEM_EXCEPTIONS;\n//    } else {\n//      currElement = 0;\n//    }\n\n//  }\n\n//  /*\n//   * @see org.xml.sax.ContentHandler#chars(char[], int, int)\n//   */\n//  public override void chars(char ch[], int start, int Length) {\n//    StringBuffer chars = new StringBuffer(Length);\n//    chars.Append(ch, start, Length);\n//    String word = readToken(chars);\n//    while (word != null) {\n//      // Console.WriteLine(\"\\\"\" + word + \"\\\"\");\n//      switch (currElement) {\n//        case ELEM_CLASSES:\n//          consumer.addClass(word);\n//          break;\n//        case ELEM_EXCEPTIONS:\n//          exception.add(word);\n//          exception = normalizeException(exception);\n//          consumer.addException(getExceptionWord(exception),\n//              (ArrayList) exception.clone());\n//          exception.clear();\n//          break;\n//        case ELEM_PATTERNS:\n//          consumer.addPattern(getPattern(word), getInterletterValues(word));\n//          break;\n//      }\n//      word = readToken(chars);\n//    }\n\n//  }\n\n//  //\n//  // ErrorHandler methods\n//  //\n\n//  /*\n//   * @see org.xml.sax.ErrorHandler#warning(org.xml.sax.SAXParseException)\n//   */\n//  public override void warning(SAXParseException ex) {\n//    errMsg = \"[Warning] \" + getLocationString(ex) + \": \" + ex.GetMessage();\n//  }\n\n//  /*\n//   * @see org.xml.sax.ErrorHandler#error(org.xml.sax.SAXParseException)\n//   */\n//  public override void error(SAXParseException ex) {\n//    errMsg = \"[Error] \" + getLocationString(ex) + \": \" + ex.GetMessage();\n//  }\n\n//  /*\n//   * @see org.xml.sax.ErrorHandler#fatalError(org.xml.sax.SAXParseException)\n//   */\n//  public override void fatalError(SAXParseException ex) throws SAXException {\n//    errMsg = \"[Fatal Error] \" + getLocationString(ex) + \": \" + ex.GetMessage();\n//    throw ex;\n//  }\n\n//  /*\n//   * Returns a string of the location.\n//   */\n//  private String getLocationString(SAXParseException ex) {\n//    StringBuilder str = new StringBuilder();\n\n//    String systemId = ex.GetSystemId();\n//    if (systemId != null) {\n//      int index = systemId.lastIndexOf('/');\n//      if (index != -1) {\n//        systemId = systemId.substring(index + 1);\n//      }\n//      str.Append(systemId);\n//    }\n//    str.Append(':');\n//    str.Append(ex.GetLineNumber());\n//    str.Append(':');\n//    str.Append(ex.GetColumnNumber());\n\n//    return str.ToString();\n\n//  } // getLocationString(SAXParseException):String\n\n//  // PatternConsumer implementation for testing purposes\n//  public void addClass(String c) {\n//    Console.WriteLine(\"class: \" + c);\n//  }\n\n//  public void addException(String w, ArrayList e) {\n//    Console.WriteLine(\"exception: \" + w + \" : \" + e.ToString());\n//  }\n\n//  public void addPattern(String p, String v) {\n//    Console.WriteLine(\"pattern: \" + p + \" : \" + v);\n//  }\n\n//  public static void main(String[] args) \n//  {\n//    if (args.Length \u003e 0) {\n//      PatternParser pp = new PatternParser();\n//      pp.SetConsumer(pp);\n//      pp.parse(args[0]);\n//    }\n//  }\n//}\n\n//class HyphenationDTDGenerator {\n//  public static readonly String DTD_STRING=\n//    \"\u003c?xml version=\\\"1.0\\\" encoding=\\\"US-ASCII\\\"?\u003e\\n\"+\n//    \"\u003c!--\\n\"+\n//    \"  Copyright 1999-2004 The Apache Software Foundation\\n\"+\n//    \"\\n\"+\n//    \"  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n\"+\n//    \"  you may not use this file except in compliance with the License.\\n\"+\n//    \"  You may obtain a copy of the License at\\n\"+\n//    \"\\n\"+\n//    \"       http://www.apache.org/licenses/LICENSE-2.0\\n\"+\n//    \"\\n\"+\n//    \"  Unless required by applicable law or agreed to in writing, software\\n\"+\n//    \"  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\"+\n//    \"  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\"+\n//    \"  See the License for the specific language governing permissions and\\n\"+\n//    \"  limitations under the License.\\n\"+\n//    \"--\u003e\\n\"+\n//    \"\u003c!-- $Id: hyphenation.dtd,v 1.3 2004/02/27 18:34:59 jeremias Exp $ --\u003e\\n\"+\n//    \"\\n\"+\n//    \"\u003c!ELEMENT hyphenation-info (hyphen-char?, hyphen-min?,\\n\"+\n//    \"                           classes, exceptions?, patterns)\u003e\\n\"+\n//    \"\\n\"+\n//    \"\u003c!-- Hyphen char to be used in the exception list as shortcut for\\n\"+\n//    \"     \u003chyphen pre-break=\\\"-\\\"/\u003e. Defaults to '-'\\n\"+\n//    \"--\u003e\\n\"+\n//    \"\u003c!ELEMENT hyphen-char EMPTY\u003e\\n\"+\n//    \"\u003c!ATTLIST hyphen-char value CDATA #REQUIRED\u003e\\n\"+\n//    \"\\n\"+\n//    \"\u003c!-- Default minimun Length in chars of hyphenated word fragments\\n\"+\n//    \"     before and after the line break. For some languages this is not\\n\"+\n//    \"     only for aesthetic purposes, wrong hyphens may be generated if this\\n\"+\n//    \"     is not accounted for.\\n\"+\n//    \"--\u003e\\n\"+\n//    \"\u003c!ELEMENT hyphen-min EMPTY\u003e\\n\"+\n//    \"\u003c!ATTLIST hyphen-min before CDATA #REQUIRED\u003e\\n\"+\n//    \"\u003c!ATTLIST hyphen-min after CDATA #REQUIRED\u003e\\n\"+\n//    \"\\n\"+\n//    \"\u003c!-- char equivalent classes: space separated list of char groups, all\\n\"+\n//    \"     chars in a group are to be treated equivalent as far as\\n\"+\n//    \"     the hyphenation algorithm is concerned. The first char in a group\\n\"+\n//    \"     is the group's equivalent char. Patterns should only contain\\n\"+\n//    \"     first chars. It also defines word chars, i.e. a word that\\n\"+\n//    \"     contains chars not present in any of the classes is not hyphenated.\\n\"+\n//    \"--\u003e\\n\"+\n//    \"\u003c!ELEMENT classes (#PCDATA)\u003e\\n\"+\n//    \"\\n\"+\n//    \"\u003c!-- Hyphenation exceptions: space separated list of hyphenated words.\\n\"+\n//    \"     A hyphen is indicated by the hyphen tag, but you can use the\\n\"+\n//    \"     hyphen-char defined previously as shortcut. This is in cases\\n\"+\n//    \"     when the algorithm procedure finds wrong hyphens or you want\\n\"+\n//    \"     to provide your own hyphenation for some words.\\n\"+\n//    \"--\u003e\\n\"+\n//    \"\u003c!ELEMENT exceptions (#PCDATA|hyphen)* \u003e\\n\"+\n//    \"\\n\"+\n//    \"\u003c!-- The hyphenation patterns, space separated. A pattern is made of 'equivalent'\\n\"+\n//    \"     chars as described before, between any two word chars a digit\\n\"+\n//    \"     in the range 0 to 9 may be specified. The absence of a digit is equivalent\\n\"+\n//    \"     to zero. The '.' char is reserved to indicate begining or ending\\n\"+\n//    \"     of words. --\u003e\\n\"+\n//    \"\u003c!ELEMENT patterns (#PCDATA)\u003e\\n\"+\n//    \"\\n\"+\n//    \"\u003c!-- A \\\"full hyphen\\\" equivalent to TeX's \\\\discretionary\\n\"+\n//    \"     with pre-break, post-break and no-break attributes.\\n\"+\n//    \"     To be used in the exceptions list, the hyphen char is not\\n\"+\n//    \"     automatically added --\u003e\\n\"+\n//    \"\u003c!ELEMENT hyphen EMPTY\u003e\\n\"+\n//    \"\u003c!ATTLIST hyphen pre CDATA #IMPLIED\u003e\\n\"+\n//    \"\u003c!ATTLIST hyphen no CDATA #IMPLIED\u003e\\n\"+\n//    \"\u003c!ATTLIST hyphen post CDATA #IMPLIED\u003e\\n\";\n  \n// public static InputSource generateDTD() {\n//    return new InputSource(new StringReader(DTD_STRING));\n//  }\n//}\n//}\n"}
{"repo_name":"xasx/roslyn","ref":"refs/heads/master","path":"src/Workspaces/CoreTest/CodeCleanup/CodeCleanupTests.cs","copies":"10","content":"﻿// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.\n\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.CodeAnalysis.CodeCleanup;\nusing Microsoft.CodeAnalysis.CodeCleanup.Providers;\nusing Microsoft.CodeAnalysis.SemanticModelWorkspaceService;\nusing Microsoft.CodeAnalysis.Test.Utilities;\nusing Microsoft.CodeAnalysis.Text;\nusing Roslyn.Test.Utilities;\nusing Roslyn.Utilities;\nusing Xunit;\n\nnamespace Microsoft.CodeAnalysis.UnitTests.CodeCleanup\n{\n    using CSharp = Microsoft.CodeAnalysis.CSharp;\n\n    [UseExportProvider]\n    public class CodeCleanupTests\n    {\n#if false\n        [Fact]\n        public void DefaultCSharpCodeCleanups()\n        {\n            var codeCleanups = CodeCleaner.GetDefaultProviders(LanguageNames.CSharp);\n            Assert.NotNull(codeCleanups);\n            Assert.NotEmpty(codeCleanups);\n        }\n\n        [Fact]\n        public void DefaultVisualBasicCodeCleanups()\n        {\n            var codeCleanups = CodeCleaner.GetDefaultProviders(LanguageNames.VisualBasic);\n            Assert.NotNull(codeCleanups);\n            Assert.NotEmpty(codeCleanups);\n        }\n#endif\n\n        [Fact]\n        public async Task CodeCleaners_NoSpans()\n        {\n            var document = CreateDocument(\"class C { }\", LanguageNames.CSharp);\n            var cleanDocument = await CodeCleaner.CleanupAsync(document, ImmutableArray\u003cTextSpan\u003e.Empty);\n\n            Assert.Equal(document, cleanDocument);\n        }\n\n        [Fact]\n        public async Task CodeCleaners_Document()\n        {\n            var document = CreateDocument(\"class C { }\", LanguageNames.CSharp);\n            var cleanDocument = await CodeCleaner.CleanupAsync(document);\n\n            Assert.Equal(document, cleanDocument);\n        }\n\n        [Fact]\n        public async Task CodeCleaners_Span()\n        {\n            var document = CreateDocument(\"class C { }\", LanguageNames.CSharp);\n            var cleanDocument = await CodeCleaner.CleanupAsync(document, (await document.GetSyntaxRootAsync()).FullSpan);\n\n            Assert.Equal(document, cleanDocument);\n        }\n\n        [Fact]\n        public async Task CodeCleaners_Spans()\n        {\n            var document = CreateDocument(\"class C { }\", LanguageNames.CSharp);\n            var cleanDocument = await CodeCleaner.CleanupAsync(document, ImmutableArray.Create(\n                (await document.GetSyntaxRootAsync()).FullSpan));\n\n            Assert.Equal(document, cleanDocument);\n        }\n\n        [Fact]\n        public async Task CodeCleaners_Annotation()\n        {\n            var document = CreateDocument(\"class C { }\", LanguageNames.CSharp);\n            var annotation = new SyntaxAnnotation();\n            document = document.WithSyntaxRoot((await document.GetSyntaxRootAsync()).WithAdditionalAnnotations(annotation));\n\n            var cleanDocument = await CodeCleaner.CleanupAsync(document, annotation);\n\n            Assert.Equal(document, cleanDocument);\n        }\n\n        [Fact]\n        public void EntireRange()\n        {\n            VerifyRange(\"{|b:{|r:class C {}|}|}\");\n        }\n\n        [Fact]\n        public void EntireRange_Merge()\n        {\n            VerifyRange(\"{|r:class {|b:C { }|} class {|b: B { } |}|}\");\n        }\n\n        [Fact]\n        public void EntireRange_EndOfFile()\n        {\n            VerifyRange(\"{|r:class {|b:C { }|} class {|b: B { } |} |}\");\n        }\n\n        [Fact]\n        public void EntireRangeWithTransformation_RemoveClass()\n        {\n            var expectedResult = default(IEnumerable\u003cTextSpan\u003e);\n            var transformer = new SimpleCodeCleanupProvider(\"TransformerCleanup\", async (doc, spans, cancellationToken) =\u003e\n            {\n                var root = await doc.GetSyntaxRootAsync().ConfigureAwait(false);\n                root = root.RemoveCSharpMember(0);\n\n                expectedResult = SpecializedCollections.SingletonEnumerable(root.FullSpan);\n\n                return doc.WithSyntaxRoot(root);\n            });\n\n            VerifyRange(\"{|b:class C {}|}\", transformer, ref expectedResult);\n        }\n\n        [Fact]\n        public void EntireRangeWithTransformation_AddMember()\n        {\n            var expectedResult = default(IEnumerable\u003cTextSpan\u003e);\n            var transformer = new SimpleCodeCleanupProvider(\"TransformerCleanup\", async (doc, spans, cancellationToken) =\u003e\n            {\n                var root = await doc.GetSyntaxRootAsync().ConfigureAwait(false);\n                var @class = root.GetMember(0);\n                var classWithMember = @class.AddCSharpMember(CreateCSharpMethod(), 0);\n                root = root.ReplaceNode(@class, classWithMember);\n\n                expectedResult = SpecializedCollections.SingletonEnumerable(root.FullSpan);\n\n                return doc.WithSyntaxRoot(root);\n            });\n\n            VerifyRange(\"{|b:class C {}|}\", transformer, ref expectedResult);\n        }\n\n        [Fact]\n        public void RangeWithTransformation_AddMember()\n        {\n            var expectedResult = default(IEnumerable\u003cTextSpan\u003e);\n            var transformer = new SimpleCodeCleanupProvider(\"TransformerCleanup\", async (doc, spans, cancellationToken) =\u003e\n            {\n                var root = await doc.GetSyntaxRootAsync().ConfigureAwait(false);\n                var @class = root.GetMember(0).GetMember(0);\n                var classWithMember = @class.AddCSharpMember(CreateCSharpMethod(), 0);\n                root = root.ReplaceNode(@class, classWithMember);\n\n                expectedResult = SpecializedCollections.SingletonEnumerable(root.GetMember(0).GetMember(0).GetCodeCleanupSpan());\n\n                return doc.WithSyntaxRoot(root);\n            });\n\n            VerifyRange(\"namespace N { {|b:class C {}|} }\", transformer, ref expectedResult);\n        }\n\n        [Fact]\n        public void RangeWithTransformation_RemoveMember()\n        {\n            var expectedResult = default(IEnumerable\u003cTextSpan\u003e);\n            var transformer = new SimpleCodeCleanupProvider(\"TransformerCleanup\", async (doc, spans, cancellationToken) =\u003e\n            {\n                var root = await doc.GetSyntaxRootAsync().ConfigureAwait(false);\n                var @class = root.GetMember(0).GetMember(0);\n                var classWithMember = @class.RemoveCSharpMember(0);\n                root = root.ReplaceNode(@class, classWithMember);\n\n                expectedResult = SpecializedCollections.SingletonEnumerable(root.GetMember(0).GetMember(0).GetCodeCleanupSpan());\n\n                return doc.WithSyntaxRoot(root);\n            });\n\n            VerifyRange(\"namespace N { {|b:class C { void Method() { } }|} }\", transformer, ref expectedResult);\n        }\n\n        [Fact]\n        public void MultipleRange_Overlapped()\n        {\n            VerifyRange(\"namespace N {|r:{ {|b:class C { {|b:void Method() { }|} }|} }|}\");\n        }\n\n        [Fact]\n        public void MultipleRange_Adjacent()\n        {\n            VerifyRange(\"namespace N {|r:{ {|b:class C { |}{|b:void Method() { } }|} }|}\");\n        }\n\n        [Fact]\n        public void MultipleRanges()\n        {\n            VerifyRange(\"namespace N { class C {|r:{ {|b:void Method() { }|} }|} class C2 {|r:{ {|b:void Method() { }|} }|} }\");\n        }\n\n        [Fact]\n        [WorkItem(12848, \"DevDiv_Projects/Roslyn\")]\n        public void DontCrash_VB()\n        {\n            var code = @\"#If DEBUG OrElse TRACE Then\nImports System.Diagnostics\n#ElseIf SILVERLIGHT Then\nImports System.Diagnostics\n#Else\nImports System.Diagnostics\n#End If\n\n{|r:# {|b: |}\n    Region|} \"\"Region\"\"\n#Region \"\"more\"\"\n#End Region \n#End Region\";\n\n            VerifyRange(code, LanguageNames.VisualBasic);\n        }\n\n        [Fact]\n        [WorkItem(774295, \"http://vstfdevdiv:8080/DevDiv2/DevDiv/_workitems/edit/774295\")]\n        public async Task DontCrash_VB_2()\n        {\n            var code = @\"\nPublic Class Class1\n    Public Custom Event Event2 As EventHandler\n        AddHandler(ByVal value As EventHandler)\n        End AddHandler\n        RemoveHandler(ByVal value As EventHandler)\n        End RemoveHandler\n        RaiseEvent(ByVal sender As Object, ByVal e As EventArgs)\n            e\n    End Event\n\nEnd Class\n\";\n            var document = CreateDocument(code, LanguageNames.VisualBasic);\n            var semanticModel = await document.GetSemanticModelAsync();\n            var root = await document.GetSyntaxRootAsync();\n            var accessor = root.DescendantNodes().OfType\u003cVisualBasic.Syntax.AccessorBlockSyntax\u003e().Last();\n            var factory = new SemanticModelWorkspaceServiceFactory();\n            var service = (ISemanticModelService)factory.CreateService(document.Project.Solution.Workspace.Services);\n            var newSemanticModel = await service.GetSemanticModelForNodeAsync(document, accessor, CancellationToken.None);\n            Assert.NotNull(newSemanticModel);\n            var newDocument = CreateDocument(code, LanguageNames.VisualBasic);\n            var newRoot = await newDocument.GetSyntaxRootAsync();\n            var newAccessor = newRoot.DescendantNodes().OfType\u003cVisualBasic.Syntax.AccessorBlockSyntax\u003e().Last();\n            root = root.ReplaceNode(accessor, newAccessor);\n            document = document.WithSyntaxRoot(root);\n            accessor = root.DescendantNodes().OfType\u003cVisualBasic.Syntax.AccessorBlockSyntax\u003e().Last();\n            newSemanticModel = await service.GetSemanticModelForNodeAsync(document, accessor, CancellationToken.None);\n            Assert.NotNull(newSemanticModel);\n            var cleanDocument = await CodeCleaner.CleanupAsync(document);\n            Assert.Equal(document, cleanDocument);\n        }\n\n        [Fact]\n        [WorkItem(547075, \"http://vstfdevdiv:8080/DevDiv2/DevDiv/_workitems/edit/547075\")]\n        public void TestCodeCleanupWithinNonStructuredTrivia()\n        {\n            var code = @\"\n#Const ccConst = 0\n#If {|b:\n|}Then\nImports System\nImports System.Collections.Generic\nImports System.Linq\n \nModule Program\n    Sub Main(args As String())\n \n    End Sub\nEnd Module\";\n\n            VerifyRange(code, LanguageNames.VisualBasic);\n        }\n\n        [Fact]\n        public void RangeWithTransformation_OutsideOfRange()\n        {\n            var expectedResult = default(IEnumerable\u003cTextSpan\u003e);\n            var transformer = new SimpleCodeCleanupProvider(\"TransformerCleanup\", async (doc, spans, cancellationToken) =\u003e\n            {\n                var root = await doc.GetSyntaxRootAsync().ConfigureAwait(false);\n                var member = root.GetMember(0).GetMember(0).GetMember(0);\n                var previousToken = member.GetFirstToken().GetPreviousToken().GetPreviousToken();\n                var nextToken = member.GetLastToken().GetNextToken().GetNextToken();\n\n                root = root.ReplaceToken(previousToken, CSharp.SyntaxFactory.Identifier(previousToken.LeadingTrivia, previousToken.ValueText, previousToken.TrailingTrivia));\n                root = root.ReplaceToken(nextToken, CSharp.SyntaxFactory.Token(nextToken.LeadingTrivia, CSharp.CSharpExtensions.Kind(nextToken), nextToken.TrailingTrivia));\n\n                expectedResult = SpecializedCollections.EmptyEnumerable\u003cTextSpan\u003e();\n\n                return doc.WithSyntaxRoot(root);\n            });\n\n            VerifyRange(\"namespace N { class C { {|b:void Method() { }|} } }\", transformer, ref expectedResult);\n        }\n\n        public static CSharp.Syntax.MethodDeclarationSyntax CreateCSharpMethod(string returnType = \"void\", string methodName = \"Method\")\n        {\n            return CSharp.SyntaxFactory.MethodDeclaration(CSharp.SyntaxFactory.ParseTypeName(returnType), CSharp.SyntaxFactory.Identifier(methodName));\n        }\n\n        private void VerifyRange(string codeWithMarker, string language = LanguageNames.CSharp)\n        {\n            MarkupTestFile.GetSpans(codeWithMarker, \n                out var codeWithoutMarker, out IDictionary\u003cstring, ImmutableArray\u003cTextSpan\u003e\u003e namedSpans);\n\n            var expectedResult = namedSpans.ContainsKey(\"r\") ? namedSpans[\"r\"] as IEnumerable\u003cTextSpan\u003e : SpecializedCollections.EmptyEnumerable\u003cTextSpan\u003e();\n\n            VerifyRange(codeWithoutMarker, ImmutableArray\u003cICodeCleanupProvider\u003e.Empty, namedSpans[\"b\"], ref expectedResult, language);\n        }\n\n        private void VerifyRange(string codeWithMarker, ICodeCleanupProvider transformer, ref IEnumerable\u003cTextSpan\u003e expectedResult, string language = LanguageNames.CSharp)\n        {\n            MarkupTestFile.GetSpans(codeWithMarker, \n                out var codeWithoutMarker, out IDictionary\u003cstring, ImmutableArray\u003cTextSpan\u003e\u003e namedSpans);\n\n            VerifyRange(codeWithoutMarker, ImmutableArray.Create(transformer), namedSpans[\"b\"], ref expectedResult, language);\n        }\n\n        private void VerifyRange(string code, ImmutableArray\u003cICodeCleanupProvider\u003e codeCleanups, ImmutableArray\u003cTextSpan\u003e spans, ref IEnumerable\u003cTextSpan\u003e expectedResult, string language)\n        {\n            var result = default(IEnumerable\u003cTextSpan\u003e);\n            var spanCodeCleanup = new SimpleCodeCleanupProvider(\"TestCodeCleanup\", (d, s, c) =\u003e\n            {\n                result = s;\n                return Task.FromResult(d);\n            });\n\n            var document = CreateDocument(code, language);\n\n            CodeCleaner.CleanupAsync(document, spans, codeCleanups.Concat(spanCodeCleanup)).Wait();\n\n            var sortedSpans = result.ToList();\n            var expectedSpans = expectedResult.ToList();\n\n            sortedSpans.Sort();\n            expectedSpans.Sort();\n\n            AssertEx.Equal(expectedSpans, sortedSpans);\n        }\n\n        private static Document CreateDocument(string code, string language)\n        {\n            var solution = new AdhocWorkspace().CurrentSolution;\n            var projectId = ProjectId.CreateNewId();\n            var project = solution.AddProject(projectId, \"Project\", \"Project.dll\", language).GetProject(projectId);\n\n            return project.AddDocument(\"Document\", SourceText.From(code));\n        }\n    }\n}\n"}